{
  "PaymentForm.tsx": "import React, { useState } from 'react';\nimport { loadStripe } from '@stripe/stripe-js';\n\ninterface PaymentFormProps {\n  onPaymentSuccess?: (paymentIntent: any) => void;\n  onPaymentError?: (error: string) => void;\n  amount: number;\n  currency?: string;\n}\n\nexport default function PaymentForm({ \n  onPaymentSuccess, \n  onPaymentError, \n  amount, \n  currency = 'eur' \n}: PaymentFormProps) {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const handlePayment = async () => {\n    setLoading(true);\n    setError(null);\n    \n    try {\n      // Create payment session\n      const response = await fetch('/api/payments/create-session', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ amount, currency })\n      });\n      \n      const { sessionId } = await response.json();\n      \n      // Redirect to Stripe Checkout\n      const stripe = await loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!);\n      const { error } = await stripe!.redirectToCheckout({ sessionId });\n      \n      if (error) {\n        throw new Error(error.message);\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Payment failed';\n      setError(errorMessage);\n      onPaymentError?.(errorMessage);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <div className=\"payment-form\">\n      <h3>Complete Your Payment</h3>\n      <p>Amount: \u20ac{amount}</p>\n      \n      {error && (\n        <div className=\"error-message\">\n          {error}\n        </div>\n      )}\n      \n      <button \n        onClick={handlePayment}\n        disabled={loading}\n        className=\"payment-button\"\n      >\n        {loading ? 'Processing...' : 'Pay Now'}\n      </button>\n    </div>\n  );\n}",
  "scraper_integration_example.tsx": "// Example integration for pages/reco.tsx\nimport { useEffect, useState } from 'react';\nimport { useRecommendation } from '@/contexts/RecommendationContext';\n\nexport default function RecommendationPage() {\n  const [scraperStatus, setScraperStatus] = useState('idle');\n  const [scraperData, setScraperData] = useState(null);\n  const { recommendations, setRecommendations } = useRecommendation();\n\n  useEffect(() => {\n    // Start scraper on component mount\n    startScraper();\n  }, []);\n\n  const startScraper = async () => {\n    setScraperStatus('running');\n    \n    try {\n      // Start scraper\n      const runResponse = await fetch('/api/scraper/run', {\n        method: 'POST'\n      });\n      \n      if (!runResponse.ok) {\n        throw new Error('Failed to start scraper');\n      }\n      \n      // Poll for completion\n      const pollStatus = async () => {\n        const statusResponse = await fetch('/api/scraper/status');\n        const { status, data } = await statusResponse.json();\n        \n        if (status === 'completed') {\n          setScraperData(data);\n          setScraperStatus('completed');\n          // Update recommendations with real data\n          setRecommendations(data.programs);\n        } else if (status === 'failed') {\n          setScraperStatus('failed');\n        } else {\n          // Continue polling\n          setTimeout(pollStatus, 2000);\n        }\n      };\n      \n      pollStatus();\n    } catch (error) {\n      setScraperStatus('failed');\n      console.error('Scraper error:', error);\n    }\n  };\n\n  return (\n    <div>\n      {scraperStatus === 'running' && (\n        <div>Loading latest funding data...</div>\n      )}\n      \n      {scraperStatus === 'completed' && (\n        <div>Real-time data loaded successfully!</div>\n      )}\n      \n      {scraperStatus === 'failed' && (\n        <div>Using fallback data...</div>\n      )}\n      \n      {/* Your existing recommendation UI */}\n    </div>\n  );\n}"
}