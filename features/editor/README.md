# Editor - How It Works

## Unified Editor Scaffold (Nov 2025 refresh)

The editor now uses the `BusinessPlan` model defined in `features/editor/types/plan.ts` (see `BusinessPlan`, `Section`, `Question`, `Dataset`, `AncillaryContent`). A colocated Zustand store inside `Editor.tsx` (`useEditorStore`) owns all runtime state:

- `plan: BusinessPlan` – hydrated from section templates + legacy localStorage via `loadPlanSections()`.
- `activeSectionId`, `activeQuestionId`, `rightPanelView` – drive the sidebar/workspace/right-panel shell.
- Actions: `hydrate(productType)`, `updateAnswer`, `addDataset/KPI/media`, `requestAISuggestions`, `runRequirementsCheck`, `updateTitlePage`, `updateAncillary`, etc. All mutations call `persistPlan()` which writes back to localStorage by translating the new model to legacy `PlanSection`/`Table` structures.
- Services stay in existing files: AI (`features/editor/engine/aiHelper.ts`) and requirements (`calculateSectionProgress`) are invoked through store actions; no new directories were created per the constraint.

Layout now follows the unified three-column spec:

1. **Sidebar** – product/funding selectors, ordered section list with inline progress.
2. **SectionWorkspace** – question cards with `SimpleTextEditor`, inline AI suggestion chips and an "Ask AI" trigger that pipes into `requestAISuggestions`.
3. **RightPanel** – tabbed views (`ai`, `data`, `ancillary`, `preview`, `requirements`). Existing files were repurposed:
   - `InlineTableCreator.tsx` → `DataPanel` (datasets/KPIs/media library).
   - `SectionContentRenderer.tsx` → `PreviewPane` (read-only document preview).
   - `RequirementsModal.tsx` → `AncillaryEditorPanel` (title page, ToC, references, lightweight checker surface).

> Migration tip: legacy consumers that still import `PlanDocument` / `PlanSection` keep working because those types remain exportable at the bottom of `types/plan.ts`. New UI pieces should use `BusinessPlan` and friends going forward.

## Quick Answers to Key Questions

### How to Customize Business Plan?
**Available (in plan.settings):**
- ✅ Title Page (title, subtitle, author, date)
- ✅ Page Numbers
- ✅ Citations (simple format)
- ✅ Figure Captions
- ✅ Formatting (font, size, spacing, margins)
- ❌ Table of Contents (not implemented yet)
- ❌ Table of Figures (not implemented yet)
- ❌ Citations Manager UI (structure exists, no UI)

**Missing:** Settings panel to edit these options

### How to Create Additional Documents?
**System exists:**
- Document templates loaded per funding type
- Program-specific documents override master
- Documents stored in `plan.attachments[]`
- Types: Work Plan, Budget, CVs, Cap Table, etc.

**Missing:** UI in editor to upload/manage documents

### Where Do Prompts Come From?
1. **Section Templates** (`shared/lib/templates/sections.ts`) - Master prompts
2. **Program-Specific** - Override master prompts via API
3. **LLM Generation** - Generated from program requirements if needed

**Flow:** Master → Program Override → Display in Editor

### How Do Sections Look?
**Structure:**
- Template defines: title, description, prompts, word counts, order
- Section data: content (rich text), tables, figures, sources
- Display: Title → Prompts (if empty) → Editor → Tables (if financial)

### Should Questions Come First?
**Current:** Questions shown when section is empty
**Better:** Questions should be persistent guide (collapsible panel)

### Logical Order of Sections?
**Strategy:** 5 sections (Executive → Market → Business → Competitive → Financial)
**Submission/Review:** 10+ sections (adds Project Description, Innovation, Impact, Team, etc.)
**Order:** Determined by `order` field in template (sorted ascending)

### Editable Content?
- ✅ **Rich Text** - ReactQuill editor
- ✅ **Financial Tables** - Structure exists (`tables.revenue`, `tables.costs`, etc.)
- ✅ **Charts** - Structure exists (`figures[]` with dataRef)
- ✅ **Sources** - Structure exists (`sources[]`)
- ✅ **Fields** - Structure exists (`fields{}` for TAM/SAM/SOM)
- ❌ **No UI** - To edit tables, charts, sources, fields yet

### What Templates Are Used?
**Master Templates:**
- Based on: Horizon Europe, FFG, WKO, Sequoia, Red-White-Red Card
- Organized by: Funding Type (grants/loans/equity/visa) × Product (strategy/review/submission)
- Location: `shared/lib/templates/sections.ts`

**Program-Specific:**
- Loaded from API: `/api/programmes/{programId}/requirements`
- Override master templates
- Generated by LLM or rule-based converter

### How Structure Changes?
**Product Change:**
- Strategy → 5 sections
- Review/Submission → 10+ sections (adds detailed sections)

**Program Change:**
- Same product, different program → Program-specific sections override master
- Different prompts, requirements, word counts

**Route Change:**
- Grant → Loan → Equity → Visa → Different prompts and focus
- Same structure, different content guidance

---

## Page Navigation & URL Structure

### Entry Points
Users can enter the editor from:
1. **Direct URL**: `/editor?programId=X&product=Y&route=Z`
2. **Program Selector**: `/editor` (no params) → shows ProgramSelector
3. **Library Page**: Click "Open in Editor" → navigates with programId

### URL Parameters
- `programId` (required): The funding program ID
- `product` (optional, default: 'submission'): 'strategy' | 'review' | 'submission'
- `route` (optional, default: 'grant'): 'grant' | 'loan' | 'equity' | 'visa'

### Navigation Flow
```
/editor (no params)
    ↓
ProgramSelector shows
    ↓
User selects program
    ↓
Navigates to /editor?programId=X&product=Y&route=Z
    ↓
Editor loads sections
    ↓
User edits sections
```

## Component Structure

### 1. EditorPage (`pages/main/editor.tsx`)
**Purpose:** Next.js page wrapper
- Reads URL query parameters
- Passes them to Editor component
- Handles authentication (withAuth)
- Shows loading state while router initializes

**What it does:**
- Extracts `programId`, `route`, `product` from URL
- Passes to `<Editor>` component
- Shows loading spinner while router is ready

---

### 2. Editor Component (`features/editor/components/Editor.tsx`)
**Purpose:** Main editor container - manages everything

**What it does:**
1. **Checks for programId**
   - If no programId → shows `ProgramSelector`
   - If programId → loads sections and shows editor

2. **Loads sections** (when programId exists)
   - Calls `getSections(fundingType, product, programId)`
   - Converts templates to `PlanSection[]`
   - Creates `PlanDocument`
   - Stores section templates (for prompts)

3. **Manages state:**
   - `plan`: The full plan document
   - `sections`: Array of sections to edit
   - `activeSection`: Currently editing section (index)
   - `sectionTemplates`: Original templates (for prompts/descriptions)

4. **Handles editing:**
   - `handleSectionChange`: Updates section content, auto-saves
   - `handleAIGenerate`: Generates content using AI

5. **Renders layout:**
   - Left sidebar: Section list
   - Main area: Section editor

---

### 3. ProgramSelector (`features/editor/components/ProgramSelector.tsx`)
**Purpose:** Let user select a program before editing

**What it does:**
- Loads programs from `/api/programs`
- Shows product selection (strategy/review/submission)
- Shows program cards
- When user selects program → calls `onProgramSelect(id, product, route)`
- Navigates to `/editor?programId=X&product=Y&route=Z`

**When shown:**
- User visits `/editor` without programId
- Editor component shows this instead of editor

---

### 4. RichTextEditor (`features/editor/components/RichTextEditor.tsx`)
**Purpose:** Rich text editing component

**What it does:**
- Uses ReactQuill for rich text editing
- Shows formatting toolbar
- Handles image upload
- Shows word/character count
- Validates content length

**Used by:**
- Editor component (for each section)

---

## User Flow

### Flow 1: User Has No Program
```
1. User visits /editor
   ↓
2. Editor.tsx sees no programId
   ↓
3. Shows ProgramSelector
   ↓
4. User selects product (strategy/review/submission)
   ↓
5. User clicks a program card
   ↓
6. ProgramSelector calls onProgramSelect(id, product, route)
   ↓
7. Router navigates to /editor?programId=X&product=Y&route=Z
   ↓
8. Editor.tsx sees programId, loads sections
   ↓
9. Shows editor with sections
```

### Flow 2: User Has Program (from URL)
```
1. User visits /editor?programId=X&product=Y&route=Z
   ↓
2. EditorPage extracts params
   ↓
3. Passes to Editor component
   ↓
4. Editor.tsx sees programId
   ↓
5. Calls loadSections()
   ↓
6. getSections() loads templates
   ↓
7. Converts to PlanSection[]
   ↓
8. Shows editor with sections
```

### Flow 3: Editing a Section
```
1. User clicks section in sidebar
   ↓
2. setActiveSection(index) updates state
   ↓
3. Editor re-renders with new active section
   ↓
4. Shows:
   - Section title in header
   - Prompts (if section is empty)
   - RichTextEditor (with content)
   - Previous/Next buttons
   ↓
5. User types in RichTextEditor
   ↓
6. onChange fires → handleSectionChange()
   ↓
7. Updates section.content
   ↓
8. Auto-saves after 400ms (debounced)
   ↓
9. Sidebar updates status (✓ if has content)
```

### Flow 4: AI Generation
```
1. User clicks "Generate with AI" button
   ↓
2. handleAIGenerate() called
   ↓
3. Loads user answers (from wizard)
   ↓
4. Creates AIHelper with:
   - Section title
   - Section prompts (from template)
   - Program info
   - User answers
   ↓
5. Calls aiHelper.generateSectionContent()
   ↓
6. AI generates content
   ↓
7. Updates section.content
   ↓
8. Auto-saves
   ↓
9. User can edit generated content
```

## Layout Structure

```
┌─────────────────────────────────────────────────────────┐
│  Editor Component (full screen)                         │
│                                                          │
│  ┌──────────┐  ┌──────────────────────────────────────┐ │
│  │          │  │  Header                               │ │
│  │ Sidebar  │  │  [Section Title] [Preview] [Saving] │ │
│  │          │  └──────────────────────────────────────┘ │
│  │ Sections │                                           │
│  │ List     │  ┌──────────────────────────────────────┐ │
│  │          │  │  Main Editor Area                     │ │
│  │ [✓] 01   │  │                                       │ │
│  │ Exec     │  │  [Prompts if empty]                  │ │
│  │          │  │  [Generate AI button]                │ │
│  │ [○] 02   │  │                                       │ │
│  │ Market   │  │  ┌────────────────────────────────┐ │ │
│  │          │  │  │ RichTextEditor                   │ │ │
│  │ [○] 03   │  │  │                                  │ │ │
│  │ Business │  │  │  User types here...              │ │ │
│  │          │  │  │                                  │ │ │
│  │ Progress │  │  └────────────────────────────────┘ │ │
│  │ 2/10     │  │                                       │ │
│  │          │  │  [← Previous] [Next →]              │ │
│  │          │  └──────────────────────────────────────┘ │
│  └──────────┘                                           │
└─────────────────────────────────────────────────────────┘
```

## Component Responsibilities

### Editor.tsx
- ✅ Loads sections from templates
- ✅ Manages plan state
- ✅ Handles section navigation
- ✅ Handles content updates
- ✅ Handles AI generation
- ✅ Auto-saves
- ✅ Renders sidebar + main editor

### ProgramSelector.tsx
- ✅ Loads programs from API
- ✅ Shows product selection
- ✅ Shows program cards
- ✅ Handles program selection
- ✅ Navigates to editor with params

### RichTextEditor.tsx
- ✅ Rich text editing (ReactQuill)
- ✅ Formatting toolbar
- ✅ Image upload
- ✅ Word count
- ✅ Content validation

## Data Flow

### Loading Sections
```
Editor.tsx
    ↓
loadSections()
    ↓
getSections(fundingType, product, programId)
    ↓
Returns SectionTemplate[]
    ↓
Convert to PlanSection[]
    ↓
Create PlanDocument
    ↓
setSections() + setPlan()
    ↓
Render editor
```

### Saving Content
```
User types
    ↓
RichTextEditor onChange
    ↓
handleSectionChange(sectionKey, content)
    ↓
Update sections array
    ↓
Update plan
    ↓
Debounce (400ms)
    ↓
savePlanSections() → localStorage
```

### AI Generation
```
User clicks "Generate with AI"
    ↓
handleAIGenerate()
    ↓
Load user answers
    ↓
Create AIHelper
    ↓
Get section template (for prompts)
    ↓
aiHelper.generateSectionContent()
    ↓
Get generated content
    ↓
handleSectionChange() → updates section
    ↓
Auto-saves
```

## Key Features

1. **Section-by-section editing**: One section at a time
2. **Sidebar navigation**: Click any section to jump
3. **Prompts display**: Shows guiding questions when section is empty
4. **AI generation**: Generate content per section
5. **Auto-save**: Saves automatically after typing stops
6. **Progress tracking**: Shows completed sections in sidebar
7. **Previous/Next**: Navigate sequentially

## State Management

### Editor State
```typescript
{
  plan: PlanDocument | null        // Full plan
  sections: PlanSection[]          // Sections to edit
  sectionTemplates: SectionTemplate[]  // Original templates (for prompts)
  activeSection: number            // Currently editing (index)
  isLoading: boolean               // Loading sections
  isSaving: boolean                // Saving indicator
}
```

### PlanSection Structure
```typescript
{
  key: string              // Section ID
  title: string           // Display title
  content: string          // Rich text (HTML)
  status: 'missing' | 'needs_fix' | 'aligned'
  wordCountMin?: number
  wordCountMax?: number
  required: boolean
  order: number
  tables?: {...}           // Financial tables (if financial section)
  figures?: {...}          // Charts
  sources?: {...}          // References
}
```

## Summary

**Simple flow:**
1. User enters `/editor` (with or without programId)
2. If no programId → show ProgramSelector
3. If programId → load sections → show editor
4. User edits sections one at a time
5. Content auto-saves
6. User can generate AI content per section
7. User can navigate via sidebar or Previous/Next

**Key principle:** One section at a time, simple navigation, auto-save, AI help when needed.

