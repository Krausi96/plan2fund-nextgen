/**
 * PreviewPanel - Live preview of the business plan
 * Shows formatted preview using react-pdf
 * Based on strategic analysis report recommendations
 */

import React, { useState, useEffect } from 'react';
import { FileText, Download, Eye, EyeOff, AlertCircle, CheckCircle } from 'lucide-react';
import { Button } from '@/shared/components/ui/button';
import { Card } from '@/shared/components/ui/card';
import { Badge } from '@/shared/components/ui/badge';
import { Document, Page, Text, View, StyleSheet, pdf } from '@react-pdf/renderer';
import { useUser } from '@/shared/contexts/UserContext';
import { isFeatureEnabled, getSubscriptionTier } from '@/shared/lib/featureFlags';
import UpgradeModal from '@/shared/components/UpgradeModal';
import { ReadinessValidator, QualityGateStatus, transformCategorizedToProgramRequirements } from '@/shared/lib/readiness';

interface PreviewPanelProps {
  plan: any;
  sections: any[];
  planContent?: Record<string, any>;
  programId?: string;
  programProfile?: any;
}

// PDF Document Component
const PDFDocument = ({ plan, sections }: PreviewPanelProps) => (
  <Document>
    <Page size="A4" style={styles.page}>
      {/* Header */}
      <View style={styles.header}>
        <Text style={styles.title}>{plan?.title || 'Business Plan'}</Text>
        {plan?.subtitle && <Text style={styles.subtitle}>{plan.subtitle}</Text>}
        {plan?.author && <Text style={styles.meta}>Prepared by: {plan.author}</Text>}
        {plan?.date && <Text style={styles.meta}>Date: {plan.date}</Text>}
      </View>

      {/* Table of Contents */}
      <View style={styles.toc}>
        <Text style={styles.tocTitle}>Table of Contents</Text>
        {sections.map((section, index) => (
          <Text key={section.key || index} style={styles.tocItem}>
            {index + 1}. {section.title}
          </Text>
        ))}
      </View>

      {/* Sections */}
      {sections.map((section, index) => {
        if (!section.content || section.content.trim().length === 0) {
          return null;
        }

        // Strip HTML tags for PDF
        const textContent = section.content.replace(/<[^>]*>/g, '').trim();
        if (!textContent) return null;

        return (
          <View key={section.key || index} style={styles.section} break={index > 0}>
            <Text style={styles.sectionTitle}>
              {index + 1}. {section.title}
            </Text>
            {section.description && (
              <Text style={styles.sectionDescription}>{section.description}</Text>
            )}
            <Text style={styles.sectionContent}>{textContent}</Text>
            {section.wordCount && (
              <Text style={styles.wordCount}>
                Word count: {section.wordCount}
              </Text>
            )}
          </View>
        );
      })}

      {/* Footer */}
      <View style={styles.footer}>
        <Text style={styles.footerText}>
          Generated by Plan2Fund • {new Date().toLocaleDateString()}
        </Text>
      </View>
    </Page>
  </Document>
);

// PDF Styles
const styles = StyleSheet.create({
  page: {
    padding: 40,
    fontSize: 12,
    fontFamily: 'Helvetica',
  },
  header: {
    marginBottom: 20,
    borderBottom: '1 solid #e5e7eb',
    paddingBottom: 15,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#4b5563',
    marginBottom: 8,
  },
  meta: {
    fontSize: 10,
    color: '#6b7280',
    marginTop: 4,
  },
  toc: {
    marginBottom: 30,
    borderBottom: '1 solid #e5e7eb',
    paddingBottom: 15,
  },
  tocTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 10,
  },
  tocItem: {
    fontSize: 11,
    marginBottom: 4,
    color: '#2563eb',
  },
  section: {
    marginBottom: 30,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 8,
  },
  sectionDescription: {
    fontSize: 10,
    fontStyle: 'italic',
    color: '#6b7280',
    marginBottom: 10,
  },
  sectionContent: {
    fontSize: 11,
    lineHeight: 1.6,
    color: '#374151',
    marginBottom: 8,
  },
  wordCount: {
    fontSize: 9,
    color: '#9ca3af',
    marginTop: 8,
  },
  footer: {
    marginTop: 'auto',
    paddingTop: 20,
    borderTop: '1 solid #e5e7eb',
  },
  footerText: {
    fontSize: 9,
    color: '#9ca3af',
    textAlign: 'center',
  },
});

export default function PreviewPanel({ 
  plan, 
  sections, 
  planContent = {},
  programId,
  programProfile: _programProfile
}: PreviewPanelProps) {
  const { userProfile } = useUser();
  const [qualityGateStatus, setQualityGateStatus] = useState<QualityGateStatus | null>(null);
  const [checkingQuality, setCheckingQuality] = useState(false);
  const [showPreview, setShowPreview] = useState(true);
  const [previewFormat, setPreviewFormat] = useState<'pdf' | 'html'>('pdf');
  const [pdfBlob, setPdfBlob] = useState<Blob | null>(null);
  const [showUpgradeModal, setShowUpgradeModal] = useState(false);

  // Check quality gates when planContent or sections change
  useEffect(() => {
    const checkQualityGates = async () => {
      if (!programId || Object.keys(planContent).length === 0) {
        setQualityGateStatus(null);
        return;
      }

      try {
        setCheckingQuality(true);
        
        // Fetch program requirements
        const response = await fetch(`/api/programmes/${programId}/requirements`);
        if (!response.ok) {
          setQualityGateStatus(null);
          return;
        }
        
        const data = await response.json();
        const categorizedRequirements = data.categorized_requirements || {};
        const transformedRequirements = transformCategorizedToProgramRequirements(
          categorizedRequirements,
          data
        );
        
        if (transformedRequirements) {
          const validator = new ReadinessValidator(transformedRequirements, planContent);
          const gateStatus = await validator.checkQualityGates(
            sections.map(s => ({
              id: s.id || s.key || '',
              wordCountMin: s.wordCountMin || s.word_count_min,
              wordCountMax: s.wordCountMax || s.word_count_max
            }))
          );
          setQualityGateStatus(gateStatus);
        }
      } catch (error) {
        console.error('Quality gate check failed:', error);
        setQualityGateStatus(null);
      } finally {
        setCheckingQuality(false);
      }
    };

    checkQualityGates();
  }, [planContent, sections, programId]);

  // Generate PDF blob
  useEffect(() => {
    const generatePDF = async () => {
      try {
        const doc = <PDFDocument plan={plan} sections={sections} />;
        const blob = await pdf(doc).toBlob();
        setPdfBlob(blob);
      } catch (error) {
        console.error('PDF generation error:', error);
      }
    };
    generatePDF();
  }, [plan, sections]);

  // PDF Preview
  const renderPDFPreview = () => {
    if (!showPreview) {
      return (
        <div className="flex items-center justify-center h-full text-gray-500">
          <div className="text-center">
            <EyeOff className="h-12 w-12 mx-auto mb-2 text-gray-400" />
            <p className="text-sm">Preview hidden</p>
            <Button
              onClick={() => setShowPreview(true)}
              size="sm"
              variant="outline"
              className="mt-4"
            >
              Show Preview
            </Button>
          </div>
        </div>
      );
    }

    if (!pdfBlob) {
      return (
        <div className="flex items-center justify-center h-full">
          <div className="text-center">
            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mx-auto mb-4"></div>
            <p className="text-sm text-gray-600">Generating PDF preview...</p>
          </div>
        </div>
      );
    }

    return (
      <iframe
        src={URL.createObjectURL(pdfBlob)}
        className="w-full h-full border-0"
        title="PDF Preview"
      />
    );
  };

  // HTML Preview (fallback)
  const renderHTMLPreview = () => {
    if (!showPreview) {
      return (
        <div className="flex items-center justify-center h-full text-gray-500">
          <div className="text-center">
            <EyeOff className="h-12 w-12 mx-auto mb-2 text-gray-400" />
            <p className="text-sm">Preview hidden</p>
            <Button
              onClick={() => setShowPreview(true)}
              size="sm"
              variant="outline"
              className="mt-4"
            >
              Show Preview
            </Button>
          </div>
        </div>
      );
    }

    return (
      <div className="space-y-6">
        {/* Document Header */}
        <div className="border-b border-gray-200 pb-4">
          <h1 className="text-2xl font-bold text-gray-900 mb-2">
            {plan?.title || 'Business Plan'}
          </h1>
          {plan?.subtitle && (
            <p className="text-lg text-gray-600">{plan.subtitle}</p>
          )}
          {plan?.author && (
            <p className="text-sm text-gray-500 mt-2">Prepared by: {plan.author}</p>
          )}
          {plan?.date && (
            <p className="text-sm text-gray-500">Date: {plan.date}</p>
          )}
        </div>

        {/* Table of Contents */}
        <div className="border-b border-gray-200 pb-4">
          <h2 className="text-xl font-semibold text-gray-900 mb-3">Table of Contents</h2>
          <ol className="space-y-1 text-sm">
            {sections.map((section, index) => (
              <li key={section.key || index} className="flex items-center gap-2">
                <span className="text-gray-500 w-8">{index + 1}.</span>
                <a
                  href={`#section-${index}`}
                  className="text-blue-600 hover:underline"
                >
                  {section.title}
                </a>
                {section.required && (
                  <span className="text-xs text-red-500">*</span>
                )}
              </li>
            ))}
          </ol>
        </div>

        {/* Sections */}
        <div className="space-y-8">
          {sections.map((section, index) => {
            if (!section.content || section.content.trim().length === 0) {
              return null;
            }

            return (
              <div
                key={section.key || index}
                id={`section-${index}`}
                className="border-b border-gray-200 pb-6 last:border-0"
              >
                <h2 className="text-xl font-semibold text-gray-900 mb-3">
                  {index + 1}. {section.title}
                </h2>
                {section.description && (
                  <p className="text-sm text-gray-600 mb-4 italic">
                    {section.description}
                  </p>
                )}
                <div className="prose prose-sm max-w-none text-gray-700 whitespace-pre-wrap">
                  {section.content}
                </div>
                {section.wordCount && (
                  <p className="text-xs text-gray-500 mt-2">
                    Word count: {section.wordCount}
                    {section.wordCountMin && section.wordCountMax && (
                      <span>
                        {' '}(Target: {section.wordCountMin}-{section.wordCountMax})
                      </span>
                    )}
                  </p>
                )}
              </div>
            );
          })}
        </div>

        {/* Footer */}
        <div className="border-t border-gray-200 pt-4 mt-8">
          <p className="text-xs text-gray-500 text-center">
            Generated by Plan2Fund • {new Date().toLocaleDateString()}
          </p>
        </div>
      </div>
    );
  };

  return (
    <div className="flex flex-col h-full">
      {/* Toolbar */}
      <div className="flex items-center justify-between p-4 border-b border-gray-200">
        <div className="flex items-center gap-2">
          <FileText className="h-5 w-5 text-gray-600" />
          <span className="text-sm font-medium text-gray-900">Preview</span>
        </div>
        <div className="flex items-center gap-2">
          <Button
            onClick={() => setShowPreview(!showPreview)}
            size="sm"
            variant="ghost"
          >
            {showPreview ? (
              <>
                <EyeOff className="h-4 w-4 mr-2" />
                Hide
              </>
            ) : (
              <>
                <Eye className="h-4 w-4 mr-2" />
                Show
              </>
            )}
          </Button>
          <Button
            size="sm"
            variant="outline"
            onClick={() => {
              setPreviewFormat(previewFormat === 'pdf' ? 'html' : 'pdf');
            }}
          >
            {previewFormat === 'pdf' ? 'HTML' : 'PDF'} View
          </Button>
          <Button
            size="sm"
            variant="outline"
            onClick={async () => {
              // Check premium access for PDF export
              const subscriptionTier = getSubscriptionTier(userProfile);
              if (!isFeatureEnabled('pdf_export', subscriptionTier)) {
                setShowUpgradeModal(true);
                return;
              }

              // Check quality gates before export
              if (qualityGateStatus && !qualityGateStatus.passed) {
                // Show quality gate issues
                alert(`Export blocked: Quality gates not met.\n\nIssues:\n${qualityGateStatus.issues.slice(0, 5).join('\n')}${qualityGateStatus.issues.length > 5 ? `\n... and ${qualityGateStatus.issues.length - 5} more` : ''}`);
                return;
              }
              
              if (previewFormat === 'pdf' && pdfBlob) {
                const url = URL.createObjectURL(pdfBlob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${plan?.title || 'business-plan'}.pdf`;
                a.click();
                URL.revokeObjectURL(url);
              } else {
                // Export HTML as PDF using html2pdf
                const html2pdf = (await import('html2pdf.js')).default;
                const element = document.getElementById('html-preview-content');
                if (element) {
                  html2pdf().from(element).save();
                }
              }
            }}
            disabled={checkingQuality || (qualityGateStatus !== null && !qualityGateStatus.passed)}
            title={qualityGateStatus && !qualityGateStatus.passed ? 'Quality gates not met - fix issues before exporting' : ''}
          >
            <Download className="h-4 w-4 mr-2" />
            Export
            {qualityGateStatus && qualityGateStatus.passed && (
              <CheckCircle className="h-4 w-4 ml-2 text-green-600" />
            )}
            {qualityGateStatus && !qualityGateStatus.passed && (
              <AlertCircle className="h-4 w-4 ml-2 text-red-600" />
            )}
          </Button>
        </div>
      </div>

      {/* Quality Gate Status */}
      {qualityGateStatus && (
        <div className="border-b border-gray-200 p-4 bg-white">
          <Card className={`p-4 ${qualityGateStatus.passed ? 'bg-green-50 border-green-200' : 'bg-yellow-50 border-yellow-200'}`}>
            <div className="flex items-center justify-between mb-2">
              <div className="flex items-center gap-2">
                {qualityGateStatus.passed ? (
                  <CheckCircle className="h-5 w-5 text-green-600" />
                ) : (
                  <AlertCircle className="h-5 w-5 text-yellow-600" />
                )}
                <span className="font-medium text-gray-900">
                  Quality Gate Status
                </span>
              </div>
              <Badge variant={qualityGateStatus.passed ? "secondary" : "destructive"}>
                {qualityGateStatus.overallScore}/100
              </Badge>
            </div>
            {qualityGateStatus.passed ? (
              <p className="text-sm text-green-700">
                ✓ All quality gates passed. Ready for export.
              </p>
            ) : (
              <div className="space-y-2">
                <p className="text-sm text-yellow-700 font-medium">
                  Export blocked. Please fix the following issues:
                </p>
                <ul className="text-xs text-yellow-700 list-disc list-inside space-y-1">
                  {qualityGateStatus.issues.slice(0, 3).map((issue, i) => (
                    <li key={i}>{issue}</li>
                  ))}
                  {qualityGateStatus.issues.length > 3 && (
                    <li>... and {qualityGateStatus.issues.length - 3} more issues</li>
                  )}
                </ul>
              </div>
            )}
          </Card>
        </div>
      )}

      {/* Preview Content */}
      <div className="flex-1 overflow-y-auto p-6 bg-white">
        {previewFormat === 'pdf' ? (
          <div className="w-full h-full">
            {renderPDFPreview()}
          </div>
        ) : (
          <div id="html-preview-content" className="max-w-4xl mx-auto bg-white shadow-sm rounded-lg p-8">
            {renderHTMLPreview()}
          </div>
        )}
      </div>
      
      {/* Upgrade Modal */}
      <UpgradeModal
        isOpen={showUpgradeModal}
        onClose={() => setShowUpgradeModal(false)}
        feature="pdf_export"
      />
    </div>
  );
}

